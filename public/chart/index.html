<!DOCTYPE HTML>
<html>
<head>

  <title>TradingView Charting</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, viewport-fit=cover">
  <script type="text/javascript" src="charting_library/charting_library.standalone.js"></script>
  <script type="text/javascript" src="datafeeds/udf/dist/bundle.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.4/moment.min.js"></script>
  <script type="text/javascript">

    let trades = [];
    let currentSellTrigger = 0;
    let exitLine = null;

    function getParameterByName(name) {
      name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
      var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
      return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
    }

    function drawShapes(symbol) {
      fetch("/grid_trades?symbol=" + symbol + "&timestamp=" + Date.now())
        .then((response) => {
          return response.json();
        })
        .then((grids) => {
          const totalGrids = grids.length;
          let lastBuyTrigger = -1;
          let lastSellTrigger = -1;

          grids.forEach((grid, idx, grids) => {

            //Trade marks
            const color = (grid.side == "BUY") ? "rgba(14, 203, 129)" : ((grid.stopLoss) ? "rgba(255, 165, 0)" : "rgba(246, 70, 93)");
            const buyTrigger = (grid.buyTrigger) ? 100 * (1 - grid.buyTrigger / grid.scale) : 0;
            const sellTrigger = (grid.sellTrigger / grid.scale - 1) * 100;
            const tooltip = (grid.side == "BUY") ?
              `Buy ${grid.qty} @${grid.price}\n${moment(grid.from * 1000)}\nSellTrigger: ${sellTrigger.toFixed(2)}%\nBuyTrigger: ${buyTrigger.toFixed(2)}%` :
              (grid.stopLoss) ? `Stoploss ${grid.qty} @${grid.price}\n${moment(grid.from * 1000)}` :
                `Sell ${grid.qty} @${grid.price}\n${moment(grid.from * 1000)}`;

            trades.push(
              tvWidget.activeChart().createExecutionShape()
                .setTooltip(tooltip)
                .setDirection((grid.side === "BUY") ? "buy" : "sell")
                .setArrowColor(color)
                .setTime(grid.from)
                .setPrice(grid.price))


            //Grids
            if (grid.side === "BUY") {
              tvWidget.activeChart().createMultipointShape(
                [
                  {
                    time: grid.from,
                    price: grid.lastBuyPrice
                  },
                  {
                    time: (grid.to) ? grid.to : (Date.now() / 1000),
                    price: grid.lastBuyPrice
                  }
                ],
                {
                  shape: "long_position",
                  lock: true,
                  disableSelection: true,
                  disableSave: true,
                  disableUndo: true,
                  zOrder: "top",
                  overrides: {
                    profitBackground: "rgba(14, 203, 129, 0.075)",
                    stopBackground: "rgba(246, 70, 93, 0.075)",
                    stopLevel: (grid.buyTrigger) ? grid.lastBuyPrice * (grid.scale - grid.buyTrigger) : 0,
                    profitLevel: grid.lastBuyPrice * (grid.sellTrigger - grid.scale),
                    risk: 1
                  }
                });

              //Add sell/buy % only if different
              if (sellTrigger !== lastSellTrigger || idx % 5 == 0) {
                tvWidget.activeChart().createShape(
                  {
                    time: (grid.to) ? grid.to : (Date.now() / 1000),
                    price: grid.lastBuyPrice * grid.sellTrigger / grid.scale
                  },
                  {
                    shape: "text",
                    lock: true,
                    disableSelection: true,
                    disableSave: true,
                    disableUndo: true,
                    zOrder: "top",
                    text: `${sellTrigger.toFixed(2)}%`,
                    overrides: {
                      fontsize: 6,
                      color: "rgba(14, 203, 129, 0.85)",
                    }
                  });

                lastSellTrigger = sellTrigger;
              }

              if (buyTrigger !== lastBuyTrigger || idx % 5 == 0) {
                tvWidget.activeChart().createShape(
                  {
                    time: grid.from,
                    price: grid.lastBuyPrice * grid.buyTrigger / grid.scale
                  },
                  {
                    shape: "text",
                    lock: true,
                    disableSelection: true,
                    disableSave: true,
                    disableUndo: true,
                    zOrder: "top",
                    text: `${buyTrigger.toFixed(2)}%`,
                    overrides: {
                      fontsize: 6,
                      color: "rgba(246, 70, 93, 0.85)",
                    }
                  });
                lastBuyTrigger = buyTrigger;
              }
            }

            //current lastBuyPrice
            if (idx == (totalGrids - 1) && (grid.side == 'BUY')) {
              currentSellTrigger = sellTrigger;
              tvWidget.activeChart().createMultipointShape(
                [
                  {
                    time: grid.from,
                    price: grid.lastBuyPrice
                  },
                  {
                    time: Date.now(),
                    price: grid.lastBuyPrice
                  }
                ],
                {
                  shape: "trend_line",
                  lock: true,
                  disableSelection: true,
                  disableSave: true,
                  disableUndo: true,
                  zOrder: "top",
                  overrides: {
                    linecolor: "gray",
                    extendRight: true,
                    linestyle: 1
                  }
                });
            }
          });

          return true;
        });
    }

    function clearShapes() {
      //clear grids
      tvWidget.activeChart().getAllShapes().forEach(({ name, id }) => tvWidget.activeChart().removeEntity(id));

      //clear trade events
      trades.forEach(t => t.remove())
      trades = []
    }

    function redrawShapes(symbol) {
      clearShapes()
      drawShapes(symbol);
    }

    function reDrawExitLine(price) {
      //next sell trigger
      if (exitLine)
        tvWidget.activeChart().removeEntity(exitLine)

      let trigger = currentSellTrigger || 1.5;
      //console.log(price * (100 + currentSellTrigger) / 100)

      exitLine = tvWidget.activeChart().createShape(
        {
            price: price * ( 100 + trigger) / 100,
            time: Date.now()
        },
        {
          shape: "horizontal_line",
          lock: true,
          disableSelection: true,
          disableSave: true,
          disableUndo: true,
          zOrder: "top",
          text: `${trigger.toFixed(2)}%`,
          overrides: {
            linecolor: "blue",
            linewidth: 1,
            linestyle: 1,
            showLabel: true,
            horzLabelsAlign: 'right',
            fontsize: 10,
            textcolor: 'gray',
          }
        })
    }

    function initOnReady() {
      var datafeedUrl = "";//"https://demo-feed-data.tradingview.com";
      var symbol = getParameterByName("symbol");
      //var interval  = getParameterByName("interval") || '360';

      var customDataUrl = getParameterByName("dataUrl");
      if (customDataUrl !== "") {
        datafeedUrl = customDataUrl.startsWith("https://") ? customDataUrl : `https://${customDataUrl}`;
      }

      var widget = window.tvWidget = new TradingView.widget({
        debug: true, // uncomment this line to see Library errors and warnings in the console
        fullscreen: true,
        symbol: symbol,
        //interval: interval,
        container: "tv_chart_container",

        //	BEWARE: no trailing slash is expected in feed URL
        datafeed: new Datafeeds.UDFCompatibleDatafeed(datafeedUrl),
        library_path: "charting_library/",
        locale: getParameterByName("lang") || "en",
        timezone: "exchange",
        disabled_features: ["left_toolbar", "header_symbol_search", "header_settings", "header_compare", "header_screenshot", "header_undo_redo"],
        // enabled_features: ["study_templates"],
        // charts_storage_url: 'https://saveload.tradingview.com',
        // charts_storage_api_version: "1.1",
        // client_id: 'tradingview.com',
        user_id: "public_user_id",
        theme: getParameterByName("theme"),
        //default bar style
        overrides: {
            "mainSeriesProperties.style": 8,
        }
      });
      var marksEnabled = true;

      // //Toggle control to show/hide marks
      // widget.headerReady().then(function() {
      //     var button = widget.createButton();
      //     button.setAttribute("title", "Toggle marks");
      //     button.addEventListener("click", function() {
      //         if (marksEnabled) {
      //             tvWidget.activeChart().getAllShapes().forEach((
      //               { name, id }) => tvWidget.activeChart().removeEntity(id));
      //             marksEnabled = false;
      //         } else {
      //             drawShapes(tvWidget.activeChart(), symbol);
      //             marksEnabled = true;
      //         }
      //     });
      //     button.textContent = "Marks";
      // });

      tvWidget.onChartReady(function() {
        drawShapes(symbol);

        this.activeChart().onIntervalChanged().subscribe(
          null, (interval, timeframeObj) => {
            setTimeout(function() {
              redrawShapes(symbol);
            }, 2000)
          });

        tvWidget.subscribe('onTick', (e) => {
          reDrawExitLine(e.close)
        })

        tvWidget.subscribe('reset_scales', (e) => {
          redrawShapes(symbol)
        })



      });

    };

    window.addEventListener("DOMContentLoaded", initOnReady, false);
    //TODO window resize
  </script>

</head>

<body style="margin:0px;">
<div id="tv_chart_container"></div>
</body>

</html>
