<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport'
        content='width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no'>
  <meta name='apple-mobile-web-app-capable' content='yes'>
  <meta name='apple-mobile-web-app-status-bar-style' content='black-translucent'>
  <title>Cryptocurrency Cards</title>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js'></script>
  <link href='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css' rel='stylesheet'>
  <link href='https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css' rel='stylesheet'>
  <style>
      body {
          background-color: #f8f9fa;
          padding: 20px;
      }

      .card {
          width: 18rem;
          margin-bottom: 20px;
      }

      .toggle-button {
          cursor: pointer;
          font-size: 0.85rem;
          user-select: none;
      }

      .group-header {
          font-weight: 500;
          font-size: small;
          text-align: center;
      }
  </style>
</head>
<body>
<div class='container'>
  <div id='cryptoCards' class='row justify-content-center'>
    <!-- Cryptocurrency cards will be dynamically inserted here -->
  </div>
</div>

<script src='https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js'></script>
<script>
  function generateCryptoConfig(queryString) {
    const urlParams = new URLSearchParams(queryString);
    const cryptoConfig = [];

    const colorMapping = {};
    const availableColors = [
      { color: 'bg-primary', textColor: 'text-white' },    // Blue background, white text
      { color: 'bg-warning', textColor: 'text-dark' },     // Yellow background, dark text
      { color: 'bg-success', textColor: 'text-white' },    // Green background, white text
      { color: 'bg-danger', textColor: 'text-white' },     // Red background, white text
      { color: 'bg-info', textColor: 'text-dark' },        // Light blue background, dark text
      { color: 'bg-secondary', textColor: 'text-white' },  // Gray background, white text
      { color: 'bg-dark', textColor: 'text-white' }       // Dark background, white text
    ];
    let colorIndex = 0;

    urlParams.forEach((value, key) => {
      const crypto = key.toUpperCase();  // No need to split the key

      const apiEndpoint = `https://${value}/current_grid/?symbol=${crypto.split('-')[0]}`;

      if (!colorMapping[value]) {
        colorMapping[value] = availableColors[colorIndex % availableColors.length];
        colorIndex++;
      }

      const config = {
        name: crypto,
        key: `${crypto.split('-')[0]}FDUSD`,
        apiEndpoint: apiEndpoint,
        color: colorMapping[value].color,
        textColor: colorMapping[value].textColor
      };

      cryptoConfig.push(config);
    });

    return cryptoConfig;
  }

  // Example usage:
  //const queryString = '?ethfdusd-eu=hxnxeu.mooo.com&btcfdusd-co=hxnxco.mooo.com&ethusdt-b1=b1.hxnxre.art&btcusdt-b2=b2.hxnxre.art';
  const queryString = window.location.search;
  const cryptoConfig = generateCryptoConfig(queryString);

  function createCryptoCard(crypto) {
    const card = document.createElement('div');
    const home_url = new URL(`${crypto.apiEndpoint}`).origin;
    const chart_url = crypto.apiEndpoint.replace('current_grid', 'chart');
    card.className = 'col-md-6 col-lg-3' +
      '';
    card.innerHTML = `
                <div class='card'>
                    <div class='card-header ${crypto.color} ${crypto.textColor}'>
                        <a href='${home_url}' target='_blank' class='${crypto.textColor} text-decoration-none me-2'>
                          <h5 class='card-title mb-0 d-inline-block'>${crypto.name}</h5>
                        </a>
                        <span class='float-end'>
                            <a href='${chart_url}' target='_blank' class='text-white text-decoration-none me-2'>
                                <i class='fas fa-chart-line'></i>
                            </a>
                            <span class='toggle-button' data-bs-toggle='collapse' href='#${crypto.name.toLowerCase()}PriceIncrementsContainer' role='button' aria-expanded='false' aria-controls='${crypto.name.toLowerCase()}PriceIncrementsContainer'>▼</span>
                        </span><br>
                        <span style='font-size: small' id='${crypto.name.toLowerCase()}Profit'></span> - <span id='${crypto.name.toLowerCase()}Trades' style='font-size: small' ></span></br>
                        <span style='font-size: small' id='${crypto.name.toLowerCase()}LastProfit'></span> (<span id='${crypto.name.toLowerCase()}LastTrade' style='font-size: small' ></span>)
                    </div>
                    <ul class='list-group list-group-flush'>
                        <li class='list-group-item'><strong>Price:</strong> <span id='${crypto.name.toLowerCase()}CurrentPrice'> - </span></li>
                        <li class='list-group-item'><strong>Last Buy Price:</strong> <span id='${crypto.name.toLowerCase()}AveragePrice'> - </span></li>
                        <li class='list-group-item'><strong>Total Amount:</strong> <span id='${crypto.name.toLowerCase()}TotalAmount'> - </span></li>
                        <li class='list-group-item'><strong>Grid Depth:</strong> <span id='${crypto.name.toLowerCase()}GridDepth'> - </span></li>
                        <li class='list-group-item'><strong>Last Buy Date:</strong> <span id='${crypto.name.toLowerCase()}LastBuyDate'> - </span></li>
                    </ul>
                    <div class='collapse' id='${crypto.name.toLowerCase()}PriceIncrementsContainer'>
                        <div class='group-header'>Buy amounts at current price<br>to breakeven at selling price</div>
                        <ul class='list-group list-group-flush header'>
                            <li id='${crypto.name.toLowerCase()}PriceIncrements' class='list-group'>
                                <!-- 2.5% increment items with breakeven amounts will be added here -->
                            </li>
                        </ul>
                    </div>
                </div>
            `;
    return card;
  }

  function fetchCryptoData(crypto) {
    fetch(crypto.apiEndpoint)
      .then(response => {
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        return response.json();
      })
      .then(data => {
        const cryptoData = data;

        if (cryptoData) {
          const lastBuyPrice = cryptoData.averagePrice || 0;
          const totalQty = cryptoData.totalQuantity || 0;
          const gridDepth = cryptoData.gridDepth || 0;
          const currentPrice = cryptoData.currentPrice || 0;
          const totalCummulativeQuoteQty = cryptoData.totalCummulativeQuoteQty || 0;
          const priceDelta = (currentPrice - lastBuyPrice) / lastBuyPrice * 100 || 0;
          const lastBuyDate = moment(cryptoData.lastBuyTimestamp).fromNow() || '';
          const trades = cryptoData.trades || 0;
          const profit = cryptoData.profit || 0;
          const lastTrade = moment(cryptoData.lastTrade).fromNow() || '';
          const lastProfit = cryptoData.lastProfit || 0;

          document.getElementById(`${crypto.name.toLowerCase()}Profit`).textContent = `$${profit.toFixed(2)}`;
          document.getElementById(`${crypto.name.toLowerCase()}LastProfit`).textContent = `$${lastProfit.toFixed(2)}`;
          document.getElementById(`${crypto.name.toLowerCase()}Trades`).textContent = `${trades.toFixed(0)} trades`;
          document.getElementById(`${crypto.name.toLowerCase()}LastTrade`).textContent = `${lastTrade}`;

          if (lastBuyPrice > 0) {
            document.getElementById(`${crypto.name.toLowerCase()}TotalAmount`).textContent = `$${totalCummulativeQuoteQty.toFixed(4)}`;
            document.getElementById(`${crypto.name.toLowerCase()}AveragePrice`).textContent = `$${lastBuyPrice.toFixed(2)}`;
            document.getElementById(`${crypto.name.toLowerCase()}CurrentPrice`).innerHTML = `<span>$${currentPrice.toFixed(2)} <span style='color:${priceDelta > 0 ? 'green' : 'red'}'>(${priceDelta.toFixed(2)}%)</span></span>`;
            document.getElementById(`${crypto.name.toLowerCase()}GridDepth`).textContent = gridDepth;
            document.getElementById(`${crypto.name.toLowerCase()}LastBuyDate`).textContent = lastBuyDate;
          }

          // Add 2.5% increment items to the list along with breakeven purchase amounts
          addPriceIncrementsWithBreakeven(crypto.name.toLowerCase(), currentPrice, priceDelta, lastBuyPrice, totalQty);

        } else {
          document.querySelectorAll(`#${crypto.name.toLowerCase()}Card span`).forEach(span => {
            span.textContent = 'No data available';
          });
        }
      })
      .catch(error => {
        console.error(`Error fetching ${crypto.name} data:`, error);
        document.querySelectorAll(`#${crypto.name.toLowerCase()}Card span`).forEach(span => {
          span.textContent = 'Error loading data';
        });
      });
  }

  function addPriceIncrementsWithBreakeven(cryptoName, currentPrice, priceDelta, lastBuyPrice, totalQty) {
    const incrementList = document.getElementById(`${cryptoName}PriceIncrements`);
    incrementList.innerHTML = ''; // Clear previous items

    if (priceDelta < 0) {
      const incrementStep = 1;
      const increments = Math.ceil(-priceDelta / incrementStep);

      for (let i = 1; i <= increments; i++) {
        const incrementPercent = (i * incrementStep).toFixed(2);
        const targetPrice = currentPrice * (1 + incrementPercent / 100);

        // Calculate the amount to purchase to achieve breakeven
        const additionalQty = targetPrice * (totalQty * (targetPrice - lastBuyPrice)) / (currentPrice - targetPrice);

        const listItem = document.createElement('li');
        listItem.className = 'list-group-item';
        listItem.textContent = `$${additionalQty.toFixed(4)} - @${targetPrice.toFixed(0)} - ${incrementPercent}%`;
        if (additionalQty > 0)
          incrementList.appendChild(listItem);
      }
    }
  }

  function initializeCryptoCards() {
    const cardContainer = document.getElementById('cryptoCards');
    cryptoConfig.forEach(crypto => {
      const card = createCryptoCard(crypto);
      cardContainer.appendChild(card);
      fetchCryptoData(crypto);

      // Toggle the arrow direction based on collapse state
      const toggleButton = card.querySelector('.toggle-button');
      const collapseElement = card.querySelector(`#${crypto.name.toLowerCase()}PriceIncrementsContainer`);

      collapseElement.addEventListener('shown.bs.collapse', function() {
        toggleButton.textContent = '▼';
      });

      collapseElement.addEventListener('hidden.bs.collapse', function() {
        toggleButton.textContent = '▲';
      });
    });
  }

  // Call the function when the page loads
  window.onload = initializeCryptoCards;

  // ---------------------------------------------
  // Addition Starts Here: Reload on Scroll Up
  // ---------------------------------------------

  // Track the last scroll position
  let lastScrollTop = window.pageYOffset || document.documentElement.scrollTop;
  let isReloading = false; // Flag to prevent multiple reloads

  // Function to reload crypto data
  function reloadCryptoData() {
    if (isReloading) return; // Prevent multiple simultaneous reloads
    isReloading = true;
    console.log('Reloading cryptocurrency data...');

    cryptoConfig.forEach(crypto => {
      fetchCryptoData(crypto);
    });

    // Simulate reload completion after a short delay (e.g., 1 second)
    setTimeout(() => {
      isReloading = false;
      console.log('Reload complete.');
    }, 1000); // Adjust the delay as needed
  }

  // Scroll event handler
  function handleScroll() {
    const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;

    if (currentScrollTop < lastScrollTop) {
      // User is scrolling up
      // Check if near the top (e.g., within 100px)
      if (currentScrollTop < 100) {
        reloadCryptoData();
      }
    }

    lastScrollTop = currentScrollTop <= 0 ? 0 : currentScrollTop; // For Mobile or negative scrolling
  }

  // Throttle the scroll event using requestAnimationFrame
  let scrollTimeout;
  window.addEventListener('scroll', function() {
    if (!scrollTimeout) {
      scrollTimeout = requestAnimationFrame(function() {
        handleScroll();
        scrollTimeout = null;
      });
    }
  });

  // ---------------------------------------------
  // Addition Ends Here
  // ---------
</script>
</body>
</html>
